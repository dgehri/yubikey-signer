# Remote Signing with YubiKey Proxy

This document describes how to sign code using a YubiKey connected to a remote device (NAS, router, Raspberry Pi) over HTTPS.

## Architecture

```text
┌────────────────────────────┐                    ┌──────────────────────────────┐
│   Client (Windows/Linux)   │      HTTPS         │   Proxy Server               │
│   yubikey-signer CLI       │ ◄─────────────── ► │   yubikey-proxy              │
│                            │  Bearer Token      │   + YubiKey USB              │
│  1. Compute PE hash        │                    │                              │
│  2. Fetch certificate      │──► /certificate ──►│  Read cert from PIV slot     │
│  3. Build auth attrs       │                    │                              │
│  4. Compute TBS hash       │                    │                              │
│  5. Send TBS hash          │──► /sign ─────────►│  Sign with YubiKey           │
│  6. Build PKCS7 locally    │◄── signature ──────│  Return ECDSA signature      │
│  7. Embed signature in PE  │                    │                              │
└────────────────────────────┘                    └──────────────────────────────┘
```

## Security Model

### Authentication

| Component          | Where Stored       | How Obtained                   |
| ------------------ | ------------------ | ------------------------------ |
| **Bearer Token**   | Server + Client    | Generated by admin, shared OOB |
| **YubiKey PIN**    | Server only        | Set via `YUBICO_PIN` env var   |
| **TLS Encryption** | Tunnel termination | Cloudflare or reverse proxy    |

### Bearer Token Authentication

The proxy requires a bearer token for all signing and certificate operations. This prevents unauthorized access.

**Generating a token:**

```bash
# Generate a secure random token (32 bytes, base64 encoded)
openssl rand -base64 32
# Example output: K7xH3pLm9QwR2sT6uV8wX0yZ1aB3cD4eF5gH6iJ7kL8=
```

**Server configuration:**

```bash
export YUBIKEY_PROXY_TOKEN="K7xH3pLm9QwR2sT6uV8wX0yZ1aB3cD4eF5gH6iJ7kL8="
```

**Client configuration:**

```powershell
$env:YUBIKEY_PROXY_TOKEN = "K7xH3pLm9QwR2sT6uV8wX0yZ1aB3cD4eF5gH6iJ7kL8="
```

### PIN Security

The YubiKey PIN is **never transmitted over the network**. It is:

1. Stored only on the server (via `YUBICO_PIN` environment variable)
2. Used once at proxy startup to authenticate with the YubiKey
3. YubiKey remains authenticated for all subsequent signing requests

This design prevents:

- PIN interception in transit
- PIN brute-force attacks via the network
- YubiKey lockout (3 failed PINs = permanent lock)

### What Gets Signed

Only **hash digests** are transmitted to the proxy — never the actual file content. The signing flow:

1. Client computes PE hash (SHA-256 of relevant PE sections)
2. Client builds authenticated attributes containing the PE hash
3. Client computes TBS (to-be-signed) hash of the authenticated attributes
4. Client sends the 32-byte TBS hash to proxy
5. Proxy signs the hash with YubiKey's private key
6. Client receives signature and embeds it in the PE file

## API Reference

All endpoints use POST with JSON body and require `Authorization: Bearer <token>` header.

### POST /api/v1/status

Health check endpoint (authentication optional).

```json
// Request
{ "version": "1.0" }

// Response
{
  "version": "1.0",
  "yubikey_ready": true,
  "serial": 28113390,
  "firmware_version": "5.4.3",
  "available_slots": ["9a", "9c"],
  "uptime_seconds": 3600
}
```

### POST /api/v1/certificate

Retrieve signing certificate from PIV slot.

```json
// Request
{ "version": "1.0", "slot": "9c" }

// Response
{
  "version": "1.0",
  "certificate_der_b64": "MIID..."
}
```

### POST /api/v1/sign

Sign a TBS hash digest.

```json
// Request
{
  "version": "1.0",
  "slot": "9c",
  "digest_b64": "base64-encoded-sha256-tbs-hash"
}

// Response
{
  "version": "1.0",
  "signature_b64": "base64-encoded-ecdsa-signature"
}
```

### Error Responses

```json
{
  "version": "1.0",
  "error_code": "AUTH_FAILED",
  "message": "Invalid or missing authorization token"
}
```

Error codes: `AUTH_FAILED`, `YUBIKEY_NOT_FOUND`, `NOT_AUTHENTICATED`, `INVALID_SLOT`, `SIGNING_FAILED`, `CERT_NOT_FOUND`, `VERSION_MISMATCH`, `BAD_REQUEST`, `RATE_LIMITED`

## Quick Start

### Server Setup

```bash
# Set environment variables
export YUBICO_PIN="your-yubikey-pin"
export YUBIKEY_PROXY_TOKEN="$(openssl rand -base64 32)"

# Start proxy (plain HTTP, use behind TLS terminator)
yubikey-proxy --bind 0.0.0.0:8443

# Or with TLS directly
yubikey-proxy --bind 0.0.0.0:8443 --tls-cert cert.pem --tls-key key.pem
```

### Client Usage

```powershell
# Set token
$env:YUBIKEY_PROXY_TOKEN = "your-token"

# Sign using remote YubiKey
yubikey-signer sign input.exe --output signed.exe --remote "http://192.168.1.100:8443"
```

## Router Deployment (ASUS RT-AX88U)

This section documents deploying to an ASUS router running ASUSWRT-Merlin with Entware.

### Prerequisites

- Router with Entware installed
- USB port for YubiKey
- SSH access to router

### Install Dependencies

```bash
opkg update
opkg install pcscd ccid libpcsclite
```

### Deploy Binary

The binary must be built for `aarch64-unknown-linux-musl` with pcsc-lite 2.3.3:

```powershell
# Build using Docker
docker compose -f docker/docker-compose.yml run --rm build-aarch64-static-v2

# Copy to router
scp target/aarch64-unknown-linux-musl/release/yubikey-proxy router:/jffs/
```

### Required Runtime Files

Because the router uses glibc but our binary uses musl, we need:

```text
/jffs/
├── ld-musl-aarch64.so.1.alpine   # Alpine's musl dynamic linker
├── yubikey-proxy                  # Main binary
├── libpcsclite.so.1               # pcsc-lite wrapper (musl)
├── libpcsclite_real.so.1          # pcsc-lite core (musl)
└── libgcc_s.so.1                  # GCC runtime
```

### Startup Script

Create `/jffs/scripts/start-yubikey-proxy.sh`:

```bash
#!/bin/sh
export LD_LIBRARY_PATH=/jffs
export YUBICO_PIN="your-pin"
export YUBIKEY_PROXY_TOKEN="your-token"

# Configure USB for YubiKey
YUBIKEY=$(find /sys/bus/usb/devices -name idVendor -exec grep -l 1050 {} \; 2>/dev/null | head -1 | xargs dirname)
[ -n "$YUBIKEY" ] && echo 1 > "$YUBIKEY/bConfigurationValue" 2>/dev/null

# Ensure pcscd is running
pidof pcscd >/dev/null || /opt/sbin/pcscd
sleep 2  # Wait for pcscd initialization

# Start proxy
exec /jffs/ld-musl-aarch64.so.1.alpine /jffs/yubikey-proxy --bind 0.0.0.0:18443
```

### Why musl + Alpine Runtime?

| Issue             | Solution                                 |
| ----------------- | ---------------------------------------- |
| Router has glibc  | Deploy Alpine's musl linker              |
| Binary needs musl | Run via `ld-musl-aarch64.so.1.alpine`    |
| pcsc-lite version | Build 2.3.3 to match Entware's pcscd     |
| Socket path       | Hardcode `/opt/var/run/pcscd/pcscd.comm` |

## Troubleshooting

### "The Smart card resource manager has shut down"

pcsc-lite library version mismatch. Ensure using 2.3.3 with Entware's pcscd 2.3.3.

### "supplied handle was invalid"

Timing issue — pcscd not fully initialized. Wait 2-3 seconds after starting pcscd before starting proxy.

### Signature invalid after remote signing

Ensure client sends TBS hash (hash of authenticated attributes), not PE hash. The fix was implemented in `compute_tbs_hash()`.

### YubiKey not detected

```bash
lsusb | grep Yubi                          # Check USB
ps | grep pcscd                            # Check daemon
echo 1 > /sys/bus/usb/devices/*/bConfigurationValue  # Reconfigure USB
```

## Future Improvements

1. **Eliminate pcscd** — Use direct USB/CCID or `yubico-piv-tool` FFI
2. **Fully static binary** — Embed libpcsclite, no separate library files
3. **Generic deployment** — Self-contained tarball with auto-detection
