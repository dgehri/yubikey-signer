# Remote Signing with YubiKey Proxy

This document describes how to sign code using a YubiKey connected to a remote device (NAS, router, Raspberry Pi) over HTTPS.

## Architecture

```text
┌────────────────────────────┐                    ┌──────────────────────────────┐
│   Client (Windows/Linux)   │      HTTPS         │   Proxy Server               │
│   yubikey-signer CLI       │ ◄─────────────── ► │   yubikey-proxy              │
│                            │  Bearer Token      │   + YubiKey USB              │
│  1. Compute PE hash        │                    │                              │
│  2. Fetch certificate      │──► /certificate ──►│  Read cert from PIV slot     │
│  3. Build auth attrs       │                    │                              │
│  4. Compute TBS hash       │                    │                              │
│  5. Send TBS hash          │──► /sign ─────────►│  Sign with YubiKey           │
│  6. Build PKCS7 locally    │◄── signature ──────│  Return ECDSA signature      │
│  7. Embed signature in PE  │                    │                              │
└────────────────────────────┘                    └──────────────────────────────┘
```

## Backend Options

The proxy server supports two communication backends for talking to the YubiKey:

| Backend        | Feature Flag   | pcscd Required | Best For                      |
| -------------- | -------------- | -------------- | ----------------------------- |
| **Direct USB** | `direct-usb`   | ❌ No          | Embedded systems, routers     |
| **PC/SC**      | `pcsc-backend` | ✅ Yes         | Desktop systems, full setups  |

The **Direct USB backend** communicates with the YubiKey via raw USB CCID protocol, eliminating the need for pcscd or any smart card middleware. This is the recommended choice for embedded deployments.

## Security Model

### Authentication

| Component          | Where Stored       | How Obtained                   |
| ------------------ | ------------------ | ------------------------------ |
| **Bearer Token**   | Server + Client    | Generated by admin, shared OOB |
| **YubiKey PIN**    | Server only        | Set via `YUBICO_PIN` env var   |
| **TLS Encryption** | Tunnel termination | Cloudflare or reverse proxy    |

### Bearer Token Authentication

The proxy requires a bearer token for all signing and certificate operations. This prevents unauthorized access.

**Generating a token:**

```bash
# Generate a secure random token (32 bytes, base64 encoded)
openssl rand -base64 32
# Example output: K7xH3pLm9QwR2sT6uV8wX0yZ1aB3cD4eF5gH6iJ7kL8=
```

**Server configuration:**

```bash
export YUBIKEY_PROXY_TOKEN="K7xH3pLm9QwR2sT6uV8wX0yZ1aB3cD4eF5gH6iJ7kL8="
```

**Client configuration:**

```powershell
$env:YUBIKEY_PROXY_TOKEN = "K7xH3pLm9QwR2sT6uV8wX0yZ1aB3cD4eF5gH6iJ7kL8="
```

### PIN Security

The YubiKey PIN is **never transmitted over the network**. It is:

1. Stored only on the server (via `YUBICO_PIN` environment variable)
2. Used once at proxy startup to authenticate with the YubiKey
3. YubiKey remains authenticated for all subsequent signing requests

This design prevents:

- PIN interception in transit
- PIN brute-force attacks via the network
- YubiKey lockout (3 failed PINs = permanent lock)

### What Gets Signed

Only **hash digests** are transmitted to the proxy — never the actual file content. The signing flow:

1. Client computes PE hash (SHA-256 of relevant PE sections)
2. Client builds authenticated attributes containing the PE hash
3. Client computes TBS (to-be-signed) hash of the authenticated attributes
4. Client sends the 32-byte TBS hash to proxy
5. Proxy signs the hash with YubiKey's private key
6. Client receives signature and embeds it in the PE file

## API Reference

All endpoints use POST with JSON body and require `Authorization: Bearer <token>` header.

### POST /api/v1/status

Health check endpoint (authentication optional).

```json
// Request
{ "version": "1.0" }

// Response
{
  "version": "1.0",
  "yubikey_ready": true,
  "serial": 28113390,
  "firmware_version": "5.4.3",
  "available_slots": ["9a", "9c"],
  "uptime_seconds": 3600
}
```

### POST /api/v1/certificate

Retrieve signing certificate from PIV slot.

```json
// Request
{ "version": "1.0", "slot": "9c" }

// Response
{
  "version": "1.0",
  "certificate_der_b64": "MIID..."
}
```

### POST /api/v1/sign

Sign a TBS hash digest.

```json
// Request
{
  "version": "1.0",
  "slot": "9c",
  "digest_b64": "base64-encoded-sha256-tbs-hash"
}

// Response
{
  "version": "1.0",
  "signature_b64": "base64-encoded-ecdsa-signature"
}
```

### Error Responses

```json
{
  "version": "1.0",
  "error_code": "AUTH_FAILED",
  "message": "Invalid or missing authorization token"
}
```

Error codes: `AUTH_FAILED`, `YUBIKEY_NOT_FOUND`, `NOT_AUTHENTICATED`, `INVALID_SLOT`, `SIGNING_FAILED`, `CERT_NOT_FOUND`, `VERSION_MISMATCH`, `BAD_REQUEST`, `RATE_LIMITED`

## Quick Start

### Server Setup

```bash
# Set environment variables
export YUBICO_PIN="your-yubikey-pin"
export YUBIKEY_PROXY_TOKEN="$(openssl rand -base64 32)"

# Start proxy (plain HTTP, use behind TLS terminator)
yubikey-proxy --bind 0.0.0.0:8443

# Or with TLS directly
yubikey-proxy --bind 0.0.0.0:8443 --tls-cert cert.pem --tls-key key.pem
```

### Client Usage

```powershell
# Set token
$env:YUBIKEY_PROXY_TOKEN = "your-token"

# Sign using remote YubiKey
yubikey-signer sign input.exe --output signed.exe --remote "http://192.168.1.100:8443"
```

## Router Deployment (Direct USB — Recommended)

This section documents the **recommended** deployment using direct USB/CCID, which requires no pcscd daemon or smart card middleware.

### Prerequisites

- Router or embedded device with USB port
- SSH access to the device
- YubiKey 5 series or newer

### Build the Binary

Build for `aarch64-unknown-linux-musl` with the `direct-usb` feature:

```powershell
# Build using Docker (creates fully static binary)
docker compose -f docker/docker-compose.yml run --rm build-aarch64-direct-usb

# Copy to router
scp target-docker/aarch64-unknown-linux-musl/release/yubikey-proxy dgehriger@192.168.42.1:/jffs/
```

### Deployment

Only a single binary is required:

```text
/jffs/
└── yubikey-proxy   # Self-contained, no dependencies
```

### Startup Script

Create `/jffs/scripts/start-yubikey-proxy.sh`:

```bash
#!/bin/sh
export YUBICO_PIN="your-pin"
export YUBIKEY_PROXY_TOKEN="your-token"

# Start proxy (direct USB, no pcscd needed)
exec /jffs/yubikey-proxy --bind 0.0.0.0:18443
```

### Why Direct USB?

| Benefit                  | Description                                      |
| ------------------------ | ------------------------------------------------ |
| **No pcscd required**    | Binary talks directly to YubiKey via USB CCID    |
| **Single binary**        | No library files, no runtime linker, no services |
| **Fully static**         | Works on any Linux ARM64 regardless of libc      |
| **Simpler deployment**   | Just copy the binary and run                     |
| **Lower resource usage** | No daemon overhead                               |

---

## Router Deployment (PC/SC — Legacy)

This section documents the **legacy** deployment using pcscd. Use this only if direct USB doesn't work for your hardware.

### Prerequisites

- Router with Entware installed
- USB port for YubiKey
- SSH access to router

### Install Dependencies

```bash
opkg update
opkg install pcscd ccid libpcsclite
```

### Deploy Binary

The binary must be built for `aarch64-unknown-linux-musl` with pcsc-lite 2.3.3:

```powershell
# Build using Docker
docker compose -f docker/docker-compose.yml run --rm build-aarch64-static-v2

# Copy to router
scp target/aarch64-unknown-linux-musl/release/yubikey-proxy router:/jffs/
```

### Required Runtime Files

Because the router uses glibc but our binary uses musl, we need:

```text
/jffs/
├── ld-musl-aarch64.so.1.alpine   # Alpine's musl dynamic linker
├── yubikey-proxy                  # Main binary
├── libpcsclite.so.1               # pcsc-lite wrapper (musl)
├── libpcsclite_real.so.1          # pcsc-lite core (musl)
└── libgcc_s.so.1                  # GCC runtime
```

### Startup Script (Legacy)

Create `/jffs/scripts/start-yubikey-proxy.sh`:

```bash
#!/bin/sh
export LD_LIBRARY_PATH=/jffs
export YUBICO_PIN="your-pin"
export YUBIKEY_PROXY_TOKEN="your-token"

# Configure USB for YubiKey
YUBIKEY=$(find /sys/bus/usb/devices -name idVendor -exec grep -l 1050 {} \; 2>/dev/null | head -1 | xargs dirname)
[ -n "$YUBIKEY" ] && echo 1 > "$YUBIKEY/bConfigurationValue" 2>/dev/null

# Ensure pcscd is running
pidof pcscd >/dev/null || /opt/sbin/pcscd
sleep 2  # Wait for pcscd initialization

# Start proxy
exec /jffs/ld-musl-aarch64.so.1.alpine /jffs/yubikey-proxy --bind 0.0.0.0:18443
```

### Why musl + Alpine Runtime?

| Issue             | Solution                                 |
| ----------------- | ---------------------------------------- |
| Router has glibc  | Deploy Alpine's musl linker              |
| Binary needs musl | Run via `ld-musl-aarch64.so.1.alpine`    |
| pcsc-lite version | Build 2.3.3 to match Entware's pcscd     |
| Socket path       | Hardcode `/opt/var/run/pcscd/pcscd.comm` |

## Troubleshooting

### Direct USB Backend Issues

**"No YubiKey found"**

Check USB connection and permissions:

```bash
lsusb | grep Yubi                          # Check USB enumeration
ls -la /dev/bus/usb/*/*                    # Check USB device permissions
```

On Linux, ensure udev rules allow USB access for the user running the proxy:

```bash
# /etc/udev/rules.d/70-yubikey.rules
SUBSYSTEM=="usb", ATTR{idVendor}=="1050", MODE="0666"
```

**"Failed to claim interface"**

Another process (like pcscd) may have claimed the YubiKey. Stop pcscd before using direct-usb:

```bash
killall pcscd
```

### PC/SC Backend Issues

**"The Smart card resource manager has shut down"**

pcsc-lite library version mismatch. Ensure using 2.3.3 with Entware's pcscd 2.3.3.

**"supplied handle was invalid"**

Timing issue — pcscd not fully initialized. Wait 2-3 seconds after starting pcscd before starting proxy.

### General Issues

**Signature invalid after remote signing**

Ensure client sends TBS hash (hash of authenticated attributes), not PE hash. The fix was implemented in `compute_tbs_hash()`.

**YubiKey not detected**

```bash
lsusb | grep Yubi                          # Check USB
echo 1 > /sys/bus/usb/devices/*/bConfigurationValue  # Reconfigure USB
```

## Implementation Notes

### Direct USB Backend

The direct-usb backend implements the USB CCID (Chip Card Interface Device) protocol to communicate directly with the YubiKey without any middleware:

1. **USB Discovery**: Scans for Yubico VID (`0x1050`) with known PIDs
2. **CCID Transport**: Uses 10-byte PC_to_RDR_XfrBlock headers for sending APDUs
3. **PIV Application**: Selects PIV AID (`A0 00 00 03 08`) and executes:
   - VERIFY PIN (INS 0x20)
   - GET DATA for certificate retrieval
   - GENERAL AUTHENTICATE (INS 0x87) for signing

This eliminates the entire PC/SC stack:

```text
Traditional:  App → libpcsclite → pcscd → libccid → USB → YubiKey
Direct USB:   App → rusb → USB → YubiKey
```

## Future Improvements

1. ~~Eliminate pcscd~~ ✅ **Done** — Direct USB/CCID backend implemented
2. **HSM support** — Support other hardware security modules via PKCS#11
3. **Certificate caching** — Cache certificate to reduce YubiKey operations
